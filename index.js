'use strict'

// alert ('Я JavaScript');

// однострочный комментарий
/* многостроынй
комментарий */


//let message // объявляем переменную message
//message = "Hello" // присваиваем ей значение
//alert (message)  // вызываем значение переменной на экран

//let message2 = "World" // объявляем и тут же присваиваем значение переменной message2

//let user ="Ded", age = "80" , message3 = "Hello" // плохая практика, низкая читаемость кода. Объявлять переменные строго на новой строке.


// можно менять значения переменных
//let value; // Объявляем переменную
//value = "1;" // Присваиваем ей значение
//value = "2"; // Присваеваем ей новое значение. Старое значение безвозвратно удаляется
//alert(value);

//можно копировать значение одной переменной напрямую в другую
//let hello = "Hello Kurwa"; // объявляем и присваиваем значение первой переменной
//let message4; // объявляем но не присваиваем значение второй
//message4 = hello; // присваиваем значение одной функции другой, одинаковые данные у обеих функций
//alert (hello);
//alert(message4);
// Имя переменной не может начинаться с цифры
// Имя переменной не может содержать спецсимволы, только $ и _
// JS регистрочувствителен!
//let - изменяемая переменная
//const - неизменяемая переменная. Может быть присвоена лишь один раз и сохранит своё значение.
// const COLOR_ORANGE = "FF7f00" - пример записи заранее известной константы. Их принято записывать заглавными.
//let admin;
//let name = "Джон";
//admin = name;
//alert (admin);


//********************************************Числа / Numbers*****************************************************
//
//Могут быть как целыми, так и с плавающей запятой.
//Let n = 12345
//n=12.345
//Есть специальные значения
//Это
//NAN - Not a number - результат ошибки, операции не над числовым значением
//Если в решении хоть где-то появляется NaN - он распространится дальше, любая операция над NaN даёт результат NaN.
//Исключение лишь NaN ** 0 - результат будет 1.  (возведение в 0 степень, результат всегда 1)
// Infinity - это + бесконечность, результат деления на 0
// -Infinity - это - бесконечность
//Математические операции в JS безопасны и не могут повесить комп. Скрипт не остановится с фатальными ошибками из-за ошибочных цифр, он выдаст NaN.
//Number\цифры ограничены диапазоном -(2**53-1) - (2**53-1) - от -9007199254740991 до 9007199254740991. Это безопасный пул. Полный доступный больше, но там присутствуют ошибки точности.
//Это связано с 64 битами на память в цикл, все цифры туда не помешаются. Начинает происходить округление до ближайшего четного числа, нечетные исчезают как явление.
//Для работы с огромными цифрами (для криптографии, или таймстампы с микросекундами) был добавлен новый тип данных - BigInt.
//Добавлен он был для работы с ЦЕЛЫМИ числами любой длины. Он задаётся буквой n в конце числового ряда.
//let a=123456789 - это обычный number
//let b=123456789n - это уже BigInt
//Но это редко необходимый тип цифр.
// BigInt не везде поддерживается, его нет в IE (пиздец потеря, но для древних скриптов это важно).


//**************************************************STRING\СТРОКА********************************************************
// Строка может быть пустой или содержать любое число символов, это всё равно будет строка.
// Строка\string всегда должна задаваться в кавычках. Вид кавычек не важен, пойдут и одинарные и двойные. "" = ''.
//let a = 'Привет'
//let b = "Привет"
// Разницы в их применении нет, обе работают одинаково.
// Всего в JS три вида кавычек:
// 1. Одинарные - ''
// 2. Двойные - ""
// 3. Обратные - ``
// Одинарные и двойные равны между собой, но обратные имеют расширенный функционал.
// Они позволяют встраивать значения выражений\переменных в стоку.

// let name2 = "Bober"; - объявляем пременную name2 со значением Bober
// alert (`Привет, ${name2}`); - выводим на экран алерт, в нём будет содержаться Привет и встроено значние переменной name2 = Привет, Bober

// Внутри ${…} происходит вычисление переменной, встраивается уже её результат. Встроено может быть что угодно.
// Встраивать могут только обратные кавычки ``, никакие другие кавычки так не смогут!


// ******************************** Bolean\ Булевые данные ****************************************
// Из названия всё ясно, эти данные могут быть только True \ False
// Используется именно для хранения этих значений. Может быть использовано для сравнений Например:

// let = nameFieldChecked = true; - присвоено значение что поле отмечено
// let = ageFieldChecked = false; - присвоено значение что поле не отмечено

//  let isGreater = 4>1; происходит сравнение 4 и 1
//  alert (isGreater); выводится на экран результат сравнения (true, ведь 4 реально больше 1)


// **************************************** Null **************************************************
// В JS это специальное значение, которое представляет собой ничто, пусто или неизвестное значение.
// Это отдельный тип данных, не относящихся ни к какому другому.
// Например
// let age = null; - значение age устанавливается как неизвестное


// ****************************************** Undefined ***********************************************
// Ещё одно специальное значение. Формирует отдельный тип данных, как и null - только из себя самого. Означает неприсвоенность значения.
// Если переменная была объявлена, но ей не было присвоено значение, то она будет равна именно undefined.
// Наример:
// let age2; - объявляем переменную, у неё нет значения, его не присвоили
// alert (age2); - выводим и видим что её значение undefined
// Отличает от null в том, что null присваевается, а undefined идёт по умолчанию. Никто не мешает присваивать переменным undefined значение,
// но это считается плохой практикой. Undefined помогает найти неприсвоенные из-за ошибки значения.


// ************************************************* Symbol \ символ *****************************************
// Для помощи в работе с object используется symbol (примерно как id в css) для создания уникальных идентификаторов внутри объектов.


// ********************************************** Object \ Объёкты ****************************************
// Сложный тип данных. Все остальные "примитивные", в них содержится только их тип данных.
//  В Object могут содержаться наборы данных или более сложные структуры.


// ************************************************** Type of *************************************************
// При применении возвращает пользователю тип указанного аргумента.
// Полезно для проверок или если данные разных типов будут обрабатываться по разному. У него 2 формы использования
// Например:
// alert (typeof 5); - выведет на экран тип данных для цифры "5" - то есть "number"
// Может применяться в виде похожем на вызов функции, но редко, например:
// alert (typeof(5)) - выведет на экран тип данных для цифры "5" - то есть "number"
// Если проверяется выражение, то оно должно заключаться в скобки, тк typeof стригеррится на первые идущие за ним данные.
// alert(typeof 50 + "квартир") - выведет на экран numberквартир, функция стригериласть на 50 и добавила "квартир следом"
// скобки необходимы для поиска типа итогового выражения в них, а не первой попавшейся его части
// alert(typeof(50+"квартир")) - выведет на экран итоговый тип данных от сложения number и string, то есть string

// let name3 = "Ya";
// alert( `hello ${1}` ); // hello 1
// alert( `hello ${"name3"}` ); // hello name3
// alert( `hello ${name3}` );  // hello Ya





// *********************************************** Alert \ Prompt \ Confirm ********************************************


// alert - показывает модальное окно с указанным сообщением. Модальное окно это окно что не даёт ни с чем другим взаимодействовать
// пока его не закроют. Например:
//alert ("Hello");  - откроет окно с текстом Hello


// prompt - отобразит модальное окно с текстом, полем для ввода текста и кнопками ок и отмена.


// result = prompt('title', [default]); - пользователь получит окно с полем ввода. Введёные туда данные попадут в переменную result.
// В случае если пользователь нажмёт "отмена", то переменной присвоится значение null.

// title - это текст для отображения в модальном окне, должен быть в кавычках
// default - цифра что забита в ответе по умолчанию
// [] квадратные скобки показывают опциональность этого параметра. Функцию можно использовать и без него.

// let age = prompt("сколько тебе лет?",''); спрашиваем пользователя, полученный ответ присваиваем как значение переменной age 
// alert (`Тебе ${age} лет, дед!`) выводим на экран string со вставленной через обратные кавычки ` переменной age
// для IE всегда нужен необязательный параметр, можно оставлять его пустым через пару пустых кавычек ''.


// ************************************************* Confirm ****************************************************
// Эта функция создаст окно с вопросом и ответами OK \ Отмена. При нажатии соответствующего ответа результату будет присвоен
// // true или false.
// result2 = confirm ("Ты за сегодня обосрался?") - создаётся окно с вопросом "Ты за сегодня обосрался?"
//  при ответе OK - переменной result присваевается значение true. При нажатии Отмена - False.


// let userName = prompt("Представься, мразь", ''); - создаём диалоговое окно, в котором запрашиваем имя у пользователя, это имя присваеваем переменной userName
// alert(`Привет, ${userName} `); - выводим на экран сообщение, в сообщение встроено значение переменной  userName


// *************************************************** Преобразование типов *******************************************************

// Операторы и функции обычно сами приводят данные в подходящий для них тип. Например alert преобразует любые входные данные в string.
// Математические операторы преобразуют всё в number

// ******************************************Строковое преобразование \ String transform ******************************************

// Используется String(value); для преобразование value в "value".

// let value = true; // - присваиваем значение true переменное value
// console.log (typeof value); // - выводим в консоль тип данных для value, видим boolean.

// value = String(value);// преобразуем тип данных value в string, теперь это не булево True, а текст "true"
// console.log (typeof value); - выводим в консоль данные о типе даннных в value, видим string.

// ******************************************** Чмсленное преобразование \ Number transform ****************************************

// Численное преобразование происходит автоматически в математичиских функциях и выражениях. Например: 
// alert ('6'*'2'); - увидим результат 12, строки преобразуются в числа в процессе математической операции умножения.

// Однако мы можем сами явно выполнить такое преобразование при помощи команды Number(value);, где value -преобразуемое значение. Например:
// let abc = '123';  задаем переменную, данные в ней - string 
// alert(typeof abc); выводим на экран уведомление о типе данных в этой переменной
// let cde = Number(abc); создаём переменную cde, которая содержит в себе преобразованную в цифры функцией Number переменную abc
// alert(typeof cde); выводим на экран тип данных переменной cde, это number

// Это явное преобразование используется когда мы планируем получать данные из текстовых полей форм или другого места,
// которое может классифицироваться не как Number. Если строка не сможет быть приведена к числу, то результатом будет NaN. Например:

// let age = Number("Текст-хуекст"); - создаём переменную age, в которой преобразуем текст из букв в число, разумеется это не получается.
// alert(age); - выводим переменную age на экран, получаем NaN из-за ошибки в преобразовании.


// Значение	Преобразуется в…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы по краям обрезаются. Если остаётся пустая строка, то получаем 0,
// из непустой строки «считывается» число. При ошибке результат NaN.

// alert( Number("   123   ") ); // 123
// alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
// alert( Number(true) );        // 1
// alert( Number(false) );       // 0

// NaN и undefined ведут себя по разному! 
// Null становится 0, а undefined превращается в NaN.

// ***************************************** Логическое преобразование \ Logical transform ***************************************

// Такой тип преобразования происходит при обработки логических выражений. Может быть явно запущено функцией Boolean(преобразуемое_значение).
// Интуитивно пустые значения (0, null, undefined, пустая строка и NaN) преобразуются в False
// Всё остальное становится True
// Например "0" это не 0, а не пустой string, который по умолчанию станет true
// следует ВНИМАТЕЛЬНО СМОТРЕТЬ НА ПРЕОБРАЗУЕМНЫЕ ДАННЫЕ

// alert(Boolean(1)); // true
// alert(Boolean(0)); // False
// alert(Boolean("Кек-чебурек")); // True - не пустой string = true
// alert(Boolean("")); // пустой string = false


// ******************************************* Basic operators Math \ Базовые операторы Математика *************************************

// Базовые операторы + - * / работают как ИРЛ.
// Однако в JS есть ряд специфичных терминов. 

// Унарный
// Бинарный
// Операнд

// Операнд - то, к чему применяется оператор. Грубо говоря слогаемое, умножаемое, делимое и делитель
// части над которыми проводится математические операции все операнды.

// Унарный оператор это опрератор, который применяется только кодному операнду. Например:

// let x = 1; задаём х
// x=-x; применяем унарный - к х, х меняет знак. 

// Бинарный это оператор, применяемый к двум опернандам. Тот же самый знак -, но у же при вычитании будет бинарным.JS
// let x = 2, y=2; //задаём х и y
// alert(x-y); //выводим на экран результат математической операции х-у, минус тут бинарный

// формально, унарный минус это отрицание - логическая операция, а не математическая.

// Математика поддерживает следующие операторы:
// + - сложение
// - - вычитание
// * - умножение
// / - деление
// % - взятие остатка после деления
// ** - возведение в степень

// % - взятие отстатка не имеет никакого отношения к процентам, несмотря на используемый символ.
// a % b это остаток от целочисленного деления а на b. Например:
// alert(5%2); // остаток от деления 5\2 это 1
// alert(8%3); // остаток от деления 8/3 это 2

// Возведение в степень прописывается **, форма записи a**b, значит а возведется в степень b. НАпример:

// alert(5**3)// 5 в третьей степени это 125

// Сложение string при помощи бинарного +
// Обычно + работают только с числами. Но в JS можно оперировать им со string.

// Форма string1 + string2 объединит их.  
// let s = "строка1" + "строка2" // задаём строки
// alert(s) // выводим на экран сложенные строки.

// Если хотя бы один из опернандов будет string, то второй преобразуется в string автоматически. Какой из опернандов будет string не имеет значения.

// let a = "stroka" + 2;
// alert(a);

// операторы работают последовательно
// alert (2+2+'1'); результатом будет 41, т.к. 2 и 2 это цифры, а '1' это string.
// alert(2+'1'+2); //даст 212 т.к. 2 цифра, 1 string, а вторая 2 это снова цифра.

// Сложение и преобразование строк свойство исключительно бинарного +.
//  Другие математические операторы не могут выполнять операции над НЕ number. и всегда преобразуют опернанды к числам
// Например:
// alert(6+'2'); // даст 62
// alert(6-'2'); // даст 4, т.к - преобразует '2' в 2

// Унарный плюс так же используется для приведения опернанда в форму number, если изначально он ей не являлся
// При этом с исходными number он ничего не делает. 

// let x = 1; // задаём х
// alert(+x); // выводим х в виде числа
// let y = (-2); // задаём у, он отрицателен
// alert(+y); // вывдим у с унарным плюсом, У ВСЁ РАВНО ОТРИЦАТЕЛЕН
// alert (+true); // преобразует True в 1 и выводит его
// alert (+""); // выводит 0, т.к. undefined преобразуется в false, а false в 0

// По функционалу это то же самое что и Number(x), но короче
// Обычео зачение полей в HTML это string, их невозможно складывать напрямую

// let apples = '2', oranges = '3'; //задаем число яблок и апельсинов как 2 и 3 в виде данных из html формы - string
// alert(apples+oranges); // выводим на экран их сумму и получаем 23, т.к. string приплюсовался к другому string

// let apples = '2', oranges = '3'; //задаем число яблок и апельсинов как 2 и 3 в виде данных из html формы - string
// alert(+apples + +oranges); // в этом случае произойдёт приведение в числовой вид перед сложением, что даст сложение 
// двух numbers с нормально работающей математикой и результатом в 5

// СУЩЕСТВУЕТ ПРИОРИТЕТ ВЫПОЛНЕНИЯ ОПЕРАТОРОВ, ЧЕМ ВЫЩЕ ТЕМ РАНЬШЕ БУДЕТ ВЫПОЛНЯТЬСЯ

// СКОБКИ ВАЖНЕЕ ПРИОРИТЕТА

// ЕСЛИ ПРИОРИТЕТ У ОПЕРАТОРОВ ОДИНАКОВЫЙ, ТО ВЫПОЛНЕНИЕ ПРОИСХОДИТ СЛЕВА НАПРАВО
// унарные операторы выполняются раньше бинарных.

// приоритет присваивания один из самых низких, это сделано для того что бы сложные переменные спера вычислялись, а после присваивались.

// Присваивание = возвращает значение, присваивание можно сипользовать как составную часть другого выражения

// let a=2, b=3; // присваиваем значения переменным а и в
// let c=3-(a=b+1); // вычисляем переменную с, в процессе должно пройти присвоение, необходимое для вычисления
// alert(c); // вывести на экран переменную с

// Присваивание возможно по цепочке
// let a,b,c; // объявляем 3 переменных
// a=b=c=2+2; // присваиваем всем трём одно значение, равное значению мат. операции.

// лучшим видом для операции будет указание в виде:
// let c=2+2;
// let b=c;
// let a=b;

// alert(a),
// alert(b);
// // alert(c);

// Арифметика с присваиванием имеет несильно отличный синтаксис:
// let n =2;
// n=n+5; функционально это n+=5;
// n=n*2; равно n*=2;

// Краткие формы с присваиванием и мат действием одновременно существуют для всех мат функций. /=, *=, -=,  **=и т.д.
// Вызов с присваиванием имеет низкий приоритет, такой же как и обычное присваивание.

// *************************************** ИНкременация\дикреминация *****************************************
// Одни из самых частых операций - увеличение на 1 \ уменьшение на 1, чаще всего применяется в циклах
// Инкремент - ++, увеличивает переменную на 1, дикримент - --, уменьшает переменную на 1.

// let a = 2; // задаем переменную
// a++; // увеличиваем переменную на 1
// alert(a); // выводим переменную

// let b = 3; // задаем переменную
// b--; // уменьшаем переменную на 1
// alert(b); // выводим переменную

// Инкремент \ декримент можно применять только к переменным, number не увеличится\уменьшится и выдаст ошибку.
// Операторы ++ и -- могут распологаться и до и после переменной
// Это называется префиксная и постфиксная формы. ++a и a++ это разные вещи. 

// let a=1; // присваемваем переменную а
// let b = ++a; // присваиваем переменной b значение ++а, идёт увеличение и возврат нового значения
// alert (b); // выводим переменную b, видим уже увеличенное значение

// let a = 1; // присваиваем переменную а
// let b= a++; // присваиваем переменной b значение a++, увеличение идёт с возвратом старого (до увеличения) значения
// alert (b);// выводим на экран переменную b, видим старое значение

// Эти операции можно использовать внутри других выражений, их приоритет выше среднего, они будут выполняться до большинства расчётов.
// let a = 1; // присваиваем переменную а
// alert (2*++a); // Выводим на экран операцию 2* на увеличенное на 1 а, то есть 2*2, видим 4.

// Если результат операции не используется, то нет разницы в каком виде проводить инкреминацию\дикременацию
// Если результат используется далее, то нужна префиксная форма ++х
// Если нужно увеличение и использование старого результата, то нужна постфиксная форма.


// Задача на префиксные и постфиксные формы

// let a = 1, b=1; // присваиваем а и в по 1
// let c = ++a; // присваиваем с, увеличение а на 1 префиксом, возвращаем 2
// let d = b++; // присваиваем d, увеличение b на 1 постфиксом, возвращаем 1
// alert (c); // выводим на экран c, видим 2
// alert(d); // выводим на экран d, видим 1


// Задача на присвоение 

// let a =2; // присваиваем а =2
// let x = 1+(a*=2);// Присваиваем х, равное 1+ 2*а = 1+4=5
// alert (x);//выводим на экран х, видим 5


// Задача на преобразования типов

// let a = "" + 1 + 0; // "" знак плюс и пустой string превратит всё выражение в string, получится пусто10
// let a = "" - 1 + 0; // знак минус не превратит выражение в сложение и string не будет участвовать в математической операции. видим -1
// let a = true + false; // true + false даст true, из-за плюса он преобразуется в 1
// let a = 6/"3"; // происходит численное преобразование, '3' преобразуется в 3
// let a = "2"*"3"; // численное преобразование, 2*3=6
// let a = 3+4+5+"px"+5+1;// сперва идут 3 number, дают в сумме 12, после идёт string и number, после появления в выражении string 
// аргумент превращается "в 12px" и сложение с 5+1 даёт "12px51"
// let a = "$"+4+5; //сложения string с number, даст "$45"
 //let a = "4"-2; // Из "4" спокойно считывается 4, выполняется операция с 2 number, результат 2
// let a = "4px"-2; // из "4px" 4 не считается, будет вычитание number из string, а это NaN
// let a = " -9 " +5; // string складывается с number, -9 5
//  let a = " -9 " -5; //пробелы из -9 откидываются, из string считывается -9 number, вычитание даст -14
// let a = null +1; // null преобразуется в 0, операция 0+1 с вдумя number
// let a = undefined +1; // undefined перобразуется в Nan, операция Nan +1 даст Nan
// let a = "\t \n" -2; // \t и \n - знаки откидываются, получается операция пусто - 2, что равно 0-2, резульатт -2
// alert (a);

// Задача на исправление

//Исходный код запрашивает два числа и должен давать их сумму. Работает неправильно, он выводит 12 (значения по умолчанию), а должен давать 3

// let a = prompt("Первое число?", 1);
// let b = prompt("Второе число?", 2);

// alert(a + b); // 12

// // Исходный код получает данные в виде string, происходит сложение стрингов, отсюда и 12. Нужно преобразовать данные в number
// let a = prompt("Первое число?", 1);
// let b = prompt("Второе число?", 2);
// a=Number(a);
// b=Number(b);
// alert(a +b); // 12

// То же самое можно сделать при помощи унарных плюслов
// let a = prompt("Первое число?", 1);
// let b = prompt("Второе число?", 2);

// alert(+a + +b); // 12


// ****************************************** Операторы сравнения JS ****************************************************
// Больше - меньше > \ <.               a>b; a<b;
// Больше или равно - меньше или равно  >= \ <=.        a>=b; a<=b;
// Равенство ==. (не =, т.к. это присваивание).          a==b
// Неравенство !=.          a!=b.


// Все операторы сравнения имеют логический тип. Результат их работы всегда True или false. Например:
// alert(2>1); // true
// alert(2==1); // false
// alert(2!=1); // true

// Результат сравнения можно присвоить как значение переменной. Например:

// let result = 5>4; // выполняем сравнение и присваиваем его результат переменной
// alert(result); // выводим на экран занчение этой переменной

// Сравнение можно применять к string
// Сравнение происходит посимвольно, сначала проверяется первая буква, затем вторая и т.д.
// Если буква по таблице unicode идёт дальше, то она больше. Например:

// alert('я'>'a'); // true, я идёт сильно позже а
// alert('Коты'>'Коды'); // true, первые две буквы равны, но т > д.
// alert('Сонный'>"Сон") // true, в первом слове тупо больше букв

// Равными считаются строки равной длины со всеми одинаковыми символами. 


// Сравнения разных типов приводит каждый из объектов к числу. НАпример:

// alert('2'>1); // true, "2" приводится в 2, а это больше одного.
// alert("01"==1); // true , "01"приводится в 1, 1=1.

// Логические True и False это 1 и 0 соответственно

// alert(1==true); // true, 1 равен 1
// alert('1'!= false); // true, 1 не равен 0

// Существует строгое сравнение. ===. Это сравнение не приводит данные  в number вид, оно сравнивает и значение и тип данных.

// Это случилось из-за того что == не способно отличить 0 от false и многих других подобных моментов.  Например:

// alert(0===false); // false, т.к. сравниваются number и boolean

// Есть аналогичный оператор строгого неравенства !==.


// alert(5>4); // true
// alert('ананас'>'яблоков') // false, а сильно меньше я
// alert('2'>'12'); //true, 2>1, это string, идёт посимвольное сравнение
// alert(undefined == null); // true, значение null=undefined и не равны любому другому значению
// alert(undefined===null); // false - это разные типы, строгое сравнение это вдятя
// alert(null == '\n0\n'); //false, null равен только undefined
// alert(null=== +"\n0\n"); // строгое сравнение разных типов данных, Всегда false

// ***************************** Ветвление If "?" ***********************************

// Для проверки условий мы можем использовать инструкцию IF и оператор условий "?"

// IF
// Инструкция IF(...) вычисляет условия в скобках, если они true, то выполняет блок кода идущий за IF.
// // Например:
// let year = prompt('В каком году ввели спецификацию ECMAScript-2015?', ''); // Выводим на экран вопрос, ответ на него присваивается переменной
// if (year == 2015) alert ("Верно!") // Проверка условия, если переменная имеет значение 2015, то выводим на экран сообщение. 

// 2015Если хотим выполнить больее одной инструкции, зависящей от условия, то эти инструкции нужно заключать в фигурные скобки. 

//  let year = prompt('В каком году ввели спецификацию ECMAScript-2015?', ''); // Выводим на экран вопрос, ответ на него присваивается переменной
//  if (year == 2015){ // выполняем проверку значения переменной, если она проходит, то выполняются два следующих alert
//     alert ("Верно!") 
//     alert ('Вы очень умны')
//  } 

// Скобки лучше использовать всегда, они помогают лучше читать код. 

// IF(...) вычисляет выражение и даёт ответ в виде логического утверждения
// "", null, undefined и NaN становятся False
// Всё остальное становится True 

// Получается что код:
// If (0) {
// ...
// };
// Никогда не будет выполнен, т.к. 0 Falsy и даст False

// А код:
// If (1) {
//     ...
//     };
// Будет выполнятсья всегда.

// Мы можем передавать заранее вычисленные в переменной логические значения в IF 

// let year = prompt('В каком году приняли ХХХ?', "")
// let condition = (year ==2015);
// if (condition){
// alert("Да, сука!")
// };

// ELSE
// Блок IF может содержать необязательный блок else, выполняемый в случае если условие основное False
// let year = prompt("Когда была хуйня?", '');
// if(year == 2015){
//     alert('ДА, Сука!');
// } else {
//     alert('А вот нихуя!');
// }

// Когда нужно проверить несколько блоков условий используется конструкция ELSE-if;

// let year = prompt ('В каком году опубликовали ECMAScript?','');
// if (year < 2015){
//     alert ('Рановато...');
// } else if (year > 2015) {
//     alert("Поздновато");
// } else {
//     alert('Верно!')
// };

// Условный оператор ?
// В случае проверки переменной в зависимости от условия мы можем создать обычную проверку через else-if, например:

// let a; // задаем переменную а
// let age = prompt("Вставь цифру",""); // запрашиваем возраст у пользователя
// if (age>18) {
//     a = true; // Если возраст больше 18, то а = тру
// } else {
//     a = false; // если возраст не больше 18, то а = фалсе
// }
// alert(a); // Выводим значение а на экран

// Однако условный оператор позволит сделать это намного короче. 
// Это особенный оператор, он имеет три аргумента.Однако
// let result = Условие ? значение1 : значение2;
// Сначала выполняется проверка условия, если оно истино - возвращается значение1, если ложно - значение2. 
// let age = prompt("Ебало к осмотру","");1
// let ageControll = (age>18) ? true : false;
// alert(ageControll);

// Возможно использовать ? для проверки значения более чем на одно условие

// let age = prompt('Сколько лет?', ''); //Запрашиваем значение и присваиваем его перемеонной age 
// let message = (age<3) ? "Привет, мелкий!" : Присваиваем переменной message значение проверяя значение переменной age, до 3 лет одно
// (age<18) ? "Привет, бандит!" : // 3-18 второе
// (age<100) ? "Привет, развалина!": "Странный возраст"; // 18-100 третье, на другие цифры - четвертое
// alert(message); // выводим значение переменной message 

// Задачи

// Выведется ли сообщение?
// if ("0"){
//     alert("Привет!") // Должно вывестись, т.к. условие "0" это не пустой string, который должен стать True и стриггерить сообщение
// }

// Задача 2 

// Используя конструкцию if..else, напишите код, который будет спрашивать: „Какое «официальное» название JavaScript?“

// Если пользователь вводит «ECMAScript», то показать: «Верно!», в противном случае – отобразить: «Не знаете? ECMAScript!»

// let scriptName = prompt('Какое "официальное" название JavaScript', "");
// if (scriptName == "ECMAScript") {
//     alert("Верно!");
// } else {
//     alert("Не заете? ECMAScript!")
// }


// Задача 3

// Используя конструкцию if..else, напишите код, который получает число через prompt, а затем выводит в alert:

// 1, если значение больше нуля,
// -1, если значение меньше нуля,
// 0, если значение равно нулю.
// Предполагается, что пользователь вводит только числа.


// let userNumber = prompt("Введите число", '')
// if (userNumber>=1) {
//      alert("1");
//  } else if(userNumber ==0) {
//      alert("0")
//  } else {
//      alert("-1")

//  }
// Задача  4

// Перепишите конструкцию if с использованием условного оператора '?':
// let result;

// if (a + b < 4) {
//   result = 'Мало';
// } else {
//   result = 'Много';
// }

// let result (a+b<40) ? "Мало" : "Много";

// Задача 5
// Перепишите if..else с использованием нескольких операторов '?'.

// Для читаемости рекомендуется разбить код на несколько строк.

// let message;

// if (login == 'Сотрудник') {
//   message = 'Привет';
// } else if (login == 'Директор') {
//   message = 'Здравствуйте';
// } else if (login == '') {
//   message = 'Нет логина';
// } else {
//   message = '';
// }

// let message = (login=="Сотрудник") ? "Привет" :
// (login == "Директор") ? "Здравствуйте" :
//  (login = "") "Нет логина":
//   "";

// ****************************************** Логические операторы ***********************************

// || ИЛИ. Оператор присваивания логического ИЛИ это ||=
// && - И.
//  Оператор присваивания логического И это &&=
// ! - НЕ
// ?? - оператор НУЛЕВОГО СЛИЯНИЯ. 
// Оператор нулевого присваивания это ??=

// ИЛИ ||. Например:
// reuslt = a||b;
// Традиционно ИЛИ предназначен для работы с булевыми значениями. Если хоть один из аргументов true, ИЛИ вернёт значение true. 
// False вернётся только если оба исхожных значения равны false 

// Однако в JS он работает немного по другому. 

// Для стандартных операций над булевыми значениями всё как обычно:

// alert(true || true);// true
// alert(false || true);// true
// alert(true || false);// true
// alert(false || false);// false

// Если выполняется операция не над логическим значением, то оно к нему приводятся для выполнения операции

// if (1||0){ // работает как if (true || false), такое ИЛИ даст true, а значит код выполнится.
// alert('Верно!')
// }

// Обычно || используется в сочетании с IF для проверки истинности любого из условий 
// let hour = 19;
// if (hour <10 || hour >18){ // Выполняется проверка сразу двух условий, код сработает если хоть одно из условий выполнится. 
//     alert('Офис закрыт!');
// }

// Сравнивать таким образом можно больше 2х условий

// let hour = 12;
// let isWeekend = true;
// if (hour <9 || hour>18 || isWeekend) {
//     alert("Офис закрыт!");
// }

// // Выше показаны стандартные возможности и применение

// При работе с несколькими значениями и оператором ИЛИ || 
// result = A||B||C;
// || вычисляет опернанды слева направо
// Каждый из опернандов конвертирует в логическое значение. Если результат true, останавливается и возвращает испходное значение этого опернанда
// Если все опернанды false, то возвращает последний из них. 
// Значение возвращается в исходном виде, без преобразования. 

// Получается что || возвращает первое истинное значение в цепочке или возвращает последнее ложное если вся цепочка ложная.
// Например:
// alert (1||0); //- 1,  т.к. 1 истинное значение
// alert(true||'string'); // true
// alert (null||1); // 1 - т.к. это первое истинное значение.
// alert (null||0||1); // 1 - т.к. это первое истинное значение
// alert(undefined||null||0); // 0, т.к. это последнее ложное в цепочке

// Примеры применения этих возможностей


// 1. Получение первого истинного значения из списка переменных или выражений.

// Например, у нас есть переменные firstName, lastName и nickName, все они необязательные (т.е. они могут быть неопределенными или иметь ложные значения).

// Давайте воспользуемся оператором ИЛИ ||, чтобы выбрать ту переменную, в которой есть данные, и показать её (или «Аноним», если ни в одной переменной данных нет):

// let firstName = '';
// let lastName = '';
// let nickName = 'Суперкодер';
// alert (firstName || lastName || nickName); // Супеокодер, т.к. это первое "true" в цепочке


// 2. Сокращённое вычисление 

// || ИЛИ обозначает свои опернанды до тех пор, пока не будет достигнуто первое истинное значение. После его нахождения алгоритм останавливается
// даже не затрагивая другие его части. 
// Важность этого становится очевидной если опернанд это выражение с каким-либо эффектом, например эффектом присвоения или вызова функции

// Например:
// true || alert("Не сработает"); //  alert не будет срабатывать т.к. нашёл первый же true и остановил выполнение строки.
// false || alert ('Всегда сработает'); // alert сработает, т.к. из 2х ложный опернандов выполнит последний, а это alert

// Эту особенность иногда используют для выполнения инструкций только в случае ложности первой половины выражений

// ||= - логическое присваивание ИЛИ

// A||=B;
// Оператор ||= видит два опернанда и делает следующее:
// Вычисляет опернанды слева направо
// конвертирует А в логическое значение
// Если А false, то присваивает переменной А значение В.

// Его работа заключается в сокращённом вычислении. 
// В виде сокращённого вычисления a||=b будет выглядеть как a||(a=b);

// Это очевидное применение оператора ||=
// let johnHasCar = false; // изначальное значение переменной
// johnHasCar ||= 'У  Джона нет машины'; // если переменная false, то ей присвоится значение ""
// alert(johnHasCar); // вывод на экран значения переменной.

// // А вот запуск логического значения
// let manufacturer = ''; // задается пустjq string вместо значения
// manufacturer ||= 'Неизвестный производитель'; // происходит логическое преобразование пустого string в false,
// //  преобразуется вторая половина, тоже false. Из двух False выбирается последний, 
// // его значение до преобразование присваивается как новое значение переменной
// alert(manufacturer); // выводим на экран значение переменной, получаем "Неизвестный производитель"

// Этот оператор (||=) добавили исключительно для легкости работы людям. Помогает сокращать выражения If с присвоением. 

// && И
// result = a && b;
// Традиционно если оба аргумента true возвращает true, иначе - false. 

// alert(true && true  ); // true только в этом случае
// alert(false && true ); // false
// alert(true && false ); // false
// alert(false && false ); // false

// Примеры применения:
// С IF

// let hour = 12;
// let minute = 30;
// if (hour == 12 && minute == 30){ // проверка истинности обоих условий
//     alert('Время 12:30!');
// }

// В качестве опернанда допускается любое значнеие

// if (1 && 0 ); {
//     alert('Сработало!') // не сработает, т.к. условие это true и false, а для сработки И нужно два true 
// }

// && находит первое ложное значение.

// result = value1 && value2 && value3;

// Оператор && вычисляет опернанды слева направо
// Каждый опернанд преобразуется в логическое true \ false. Если опернанд false, то выполнение останавливается
// и возвращается исходное значение этого опернанда.
// Если все опернанды были true, то возвращается значение последнего.

// Другими словами И возвращает первое ложное значение, или последнее истинное (если ложных нет).
// Поведение похоже на ИЛИ, только И возвращает первое ложное, а ИЛИ первое истинное.

// alert ( 1 && 0 ); // Если первы опернанд true (а 1 это true), то возвращается второй
// alert ( 1 && 5 ); // Если первы опернанд true (а 1 это true), то возвращается второй

// alert ( null && 5 ); // если первый опернанд false, то возвращается он, второй игнорируется
// alert ( 0 && "непустой string"); // если первый опернанд false, то возвращается он, второй игнорируется

// Можно передавать несколько значений подряд, в таком случае возвратится первое false значение, на нём же вычисление остановится.

// alert ( 1 && 2 && null && 3); // не нулевые цифры это true, так что 1 и 2 проходят, а вот null это false, его функция и возвращает

// alert ( 1&& 2 && 3 ); // 3, т.к. Если все части true - вернётся последнее

// Приоритет && выше чем || (И выше чем ИЛИ!)


// &&= логическое присваивание И

//  a &&= b;
//  Принцип действия &&= похож на ||=. Но разница в том, что &&= присвоит а значеие b только если a true. (||= присваивал если а False)
// &&= просмотрит опернанды слева направо, конвертирует их в логические значения.
// Если а true - выполнит присваивание.

// Сокращённое вычисление так же действует, если условие не выполнится, то дальнейший код не рассматривается.

//  классический код:
// let greeting = 'Привет';
// if (greeting){
//     greeting = greeting + ', пользователь';
// }
// alert(greeting);

// Код через &&=:
// let greeting = "Привет" // string не пустой, поэтому будет true
// greeting &&= greeting + ', пользователь'; // получается что true &&= greeting+ ', пользователь'
// alert(greeting);

// На практике ||= используется куда чаще чем &&=. 

// Оператор ! (НЕ)

// result = !value;
// Сначала ! приводит аргумент к логическому виду
// После возвращает противоположное значение. 

// alert(!true); // вернет false
// alert(!0); // вернёт true

// Часто !! используют для конвертации значений в логический вид.
// alert ( !!"Что-то"); // Превратится в true
// alert ( !!null); // Первратится в false

// Первое не преобразует в логически обратную переменную, а вторая "нормализует" её.
// Аналогичную функцию выполняет встроенная функция Boolean 
// alert ( Boolean ("Текст-хуекст")); // true, т.к. string с содержимым это true
// alert ( Boolean (null)); // false, т.к. null это falsy значение

// У ! (НЕ) высший приоритет. Он выполняется всегда первым срдеди всех логических операторов.

// Задачи:
// Что выведет alert (ИЛИ)?

// alert (null || 2 || undefined); // выведет 2, т.к. остальные условия false, а ИЛИ возвращает исходный вид переменной true

// Что выведет alert (ИЛИ)?

// alert( alert(1) || 2 || alert(3) ); // alert (1) вернут undefined, ИЛИ продолжит искать следующий true элемент, а это 2.
// На этом функция остановится и вернёт 2.

// Что выведет alert (И)?
// alert (1 && null && 2); // null, т.к. это первый false из списка

// Что выведет alert (И)?
// alert( alert(1) && alert(2) ); // 1, потом undefined. Сперва 1 т.к. в скобках действие выполняется первым. undefined, т.к. alert не возвращает числа и становится undefined

// Что выведет этот код?
// alert( null || 2 && 3 || 4 ); // приоритет && выше чем ||, сперва выполнится он. из 2&&3 выберется 3, т.к. это последнее true в этой цепочке.
// Получается вид null || 3 ||4 , в нём вернётся первое true, т.е 3

// Что выведет этот код (||=, &&=)?
// let value = NaN; // NaN это falsy, то есть False
// value &&= 10; // Присваивание И не срабатывает, т.к. vlaue False
// value ||= 20; // Присваивание ИЛИ срабатывает, т.к value false, новое значение value = 20
// value &&= 30; // Присваивание И срабатывает, т.к. 20 это true
// value ||= 40; // Присваивание ИЛИ не срабатывает, т.к. 30 это true, а присваивание ИЛИ срабатывает только если false
// alert(value); // Выводится 30. 

// Проверка значения из диапазона
// let age = 91;
// if (age>=14 && age<=90) {
//     alert("Pass");
// };

// // Проверка значения вне диапазона
// if (!(age>=14 && age<==90));
// ИЛИ 
// if (age <14 || age > 90);
